<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ローソク足チャート</title>
  <style>
    body { 
      margin: 0; 
      padding: 1rem;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* ---- タイトル行＋使い方ボタン ---- */
    .title-row{
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    h1 {
      margin: 0;
      font-size: 1.5rem;
      color: #333;
    }
    .help-btn{
      font-size:12px;
      padding:3px 8px;
      background:#e0e0e0;
      color:#000;
      border:1px solid #bdbdbd;
      border-radius:4px;
      cursor:pointer;
    }
    .help-btn:hover{ background:#d5d5d5; }

    /* ---- 使い方モーダル ---- */
    .modal-overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.35);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:1000;
    }
    .modal{
      width:min(560px, calc(100vw - 40px));
      background:#fff;
      border:1px solid #ccc;
      border-radius:8px;
      box-shadow:0 8px 24px rgba(0,0,0,0.25);
      padding:14px 16px;
    }
    .modal-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .modal-title{
      font-size:14px;
      font-weight:700;
      margin:0;
    }
    .modal-close{
      font-size:12px;
      padding:3px 8px;
      background:#e0e0e0;
      color:#000;
      border:1px solid #bdbdbd;
      border-radius:4px;
      cursor:pointer;
    }
    .modal-close:hover{ background:#d5d5d5; }
    .modal-body{
      font-size:13px;
      color:#333;
      line-height:1.6;
      white-space:pre-line;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 15px;
      align-items: center;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    .param-group {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      background: #f9f9f9;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #eee;
    }
    .param-group label { font-weight: 600; color: #555; }
    .param-group input {
      width: 45px;
      padding: 2px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      text-align: center;
    }
    .slider-container {
      flex: 1;
      min-width: 250px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .slider-container input[type="range"] { flex: 1; cursor: pointer; }
    .slider-label { min-width: 120px; font-size: 13px; text-align: right; font-feature-settings: "tnum"; }
    
    .legend {
      display: flex;
      gap: 15px;
      font-size: 12px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-color { width: 12px; height: 12px; border-radius: 2px; }

    canvas { display: block; width: 100%; cursor: crosshair; }
    #mainChart { height: 350px; border: 1px solid #ddd; border-bottom: none; }
    
    .indicator-container {
      border: 1px solid #ddd;
      border-top: none;
      background: white;
      position: relative;
    }
    .indicator-controls {
      position: absolute;
      top: 2px; right: 2px;
      pointer-events: auto;
      display: flex; gap: 2px;
      z-index: 10;
    }
    .btn-icon {
      width: 16px; height: 16px;
      border: none;
      color: white;
      font-size: 10px;
      line-height: 1;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      border-radius: 2px;
      opacity: 0.7;
    }
    .btn-icon:hover { opacity: 1; }
    .btn-move { background: #2196f3; }
    .btn-toggle { background: #666; }
    
    .indicator-wrapper { height: 120px; transition: height 0.2s; overflow: hidden; }
    .indicator-wrapper.collapsed { height: 0; }
    .indicator-canvas { height: 100%; width: 100%; }

    .tooltip {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #999;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 100;
      line-height: 1.4;
      white-space: nowrap;
    }
  </style>
</head>
<body>

<div class="container">
  <div class="title-row">
    <h1>株価チャート</h1>
    <button id="helpBtn" class="help-btn" type="button">使い方</button>
  </div>

  <div class="controls-row" style="margin-top:15px;">
    <input type="file" id="fileInput" accept=".csv">
    <span id="status" style="font-size:13px; color:#666;">データを選択してください (形式: 日付,始値,高値,安値,終値)</span>
  </div>

  <div class="controls-row">
    <div class="slider-container">
      <label>表示本数:</label>
      <input type="range" id="countSlider" min="10" max="200" value="100">
      <span id="countLabel" class="slider-label">100本</span>
    </div>
    <div class="slider-container">
      <label>表示位置:</label>
      <input type="range" id="rangeSlider" min="0" max="0" value="0">
      <span id="rangeLabel" class="slider-label">最新</span>
    </div>
  </div>

  <div class="controls-row">
    <div class="param-group"><label>MA1</label><input type="number" id="ma1Period" value="20"></div>
    <div class="param-group"><label>MA2</label><input type="number" id="ma2Period" value="60"></div>
    <div class="param-group"><label>RSI</label><input type="number" id="rsiPeriod" value="14"></div>
    <div class="param-group"><label>Stoch K</label><input type="number" id="stochK" value="14"></div>
    <div class="param-group"><label>Stoch D</label><input type="number" id="stochD" value="3"></div>
    <div class="param-group"><label>MACD S</label><input type="number" id="macdShort" value="12"></div>
    <div class="param-group"><label>MACD L</label><input type="number" id="macdLong" value="26"></div>
    <div class="param-group"><label>Sig</label><input type="number" id="macdSignal" value="9"></div>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background:#26a69a"></div>陽線</div>
    <div class="legend-item"><div class="legend-color" style="background:#ef5350"></div>陰線</div>
    <div class="legend-item"><div class="legend-color" style="background:#ff9800"></div>MA1</div>
    <div class="legend-item"><div class="legend-color" style="background:#2196f3"></div>MA2</div>
    <div class="legend-item"><div class="legend-color" style="background:#9c27b0"></div>RSI</div>
    <div class="legend-item"><div class="legend-color" style="background:#00bcd4"></div>%K</div>
    <div class="legend-item"><div class="legend-color" style="background:#ff5722"></div>%D</div>
  </div>

  <canvas id="mainChart"></canvas>
  
  <div id="indicatorsList">
    <div class="indicator-container" id="macdContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('macd')">−</button>
      </div>
      <div class="indicator-wrapper" id="macdWrapper">
        <canvas class="indicator-canvas" id="macdChart"></canvas>
      </div>
    </div>
    
    <div class="indicator-container" id="stochContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('stoch')">−</button>
      </div>
      <div class="indicator-wrapper" id="stochWrapper">
        <canvas class="indicator-canvas" id="stochChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="rsiContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('rsi')">−</button>
      </div>
      <div class="indicator-wrapper" id="rsiWrapper">
        <canvas class="indicator-canvas" id="rsiChart"></canvas>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>
</div>

<!-- 使い方モーダル -->
<div id="helpModal" class="modal-overlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
    <div class="modal-header">
      <p class="modal-title" id="helpModalTitle">使い方</p>
      <button id="helpCloseBtn" class="modal-close" type="button">閉じる</button>
    </div>
    <div class="modal-body">
入力データの形式はCSV。ExcelをCSV保存で可（コンマ区切り）。『日付　始値　高値　安値　終値』で降順（最新データから古いデータ順）に並べる。ローカルで動作するのでデータ送受信はしない。
    </div>
  </div>
</div>

<script>
/**
 * Global State
 */
let candles = [];
let displayCount = 100;
let offsetX = 0;

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;

let params = {
  ma1: 20, ma2: 60,
  rsi: 14,
  stochK: 14, stochD: 3,
  macdShort: 12, macdLong: 26, macdSignal: 9
};

let mainCanvas, mainCtx;
let macdCanvas, macdCtx;
let stochCanvas, stochCtx;
let rsiCanvas, rsiCtx;
let tooltip;

let collapsed = { macd: false, stoch: false, rsi: false };

/* ---- 指標キャッシュ ---- */
let indicators = {
  ma1: [], ma2: [],
  rsi: [],
  stoch: { k: [], d: [] },
  macd: { macd: [], signal: [], hist: [] }
};

/* ---- クロスヘア用バックバッファ ---- */
let backBuffers = { main: null, macd: null, stoch: null, rsi: null };

function resetBackBuffers() {
  backBuffers.main = null;
  backBuffers.macd = null;
  backBuffers.stoch = null;
  backBuffers.rsi = null;
}

function saveBackBuffers() {
  try {
    backBuffers.main = mainCtx.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
    if (!collapsed.macd) backBuffers.macd = macdCtx.getImageData(0, 0, macdCanvas.width, macdCanvas.height);
    else backBuffers.macd = null;
    if (!collapsed.stoch) backBuffers.stoch = stochCtx.getImageData(0, 0, stochCanvas.width, stochCanvas.height);
    else backBuffers.stoch = null;
    if (!collapsed.rsi) backBuffers.rsi = rsiCtx.getImageData(0, 0, rsiCanvas.width, rsiCanvas.height);
    else backBuffers.rsi = null;
  } catch (e) {
    // サイズ変更中などで失敗しても致命ではない
  }
}

function restoreBackBuffers() {
  try {
    if (backBuffers.main) mainCtx.putImageData(backBuffers.main, 0, 0);
    if (!collapsed.macd && backBuffers.macd) macdCtx.putImageData(backBuffers.macd, 0, 0);
    if (!collapsed.stoch && backBuffers.stoch) stochCtx.putImageData(backBuffers.stoch, 0, 0);
    if (!collapsed.rsi && backBuffers.rsi) rsiCtx.putImageData(backBuffers.rsi, 0, 0);
  } catch (e) {
    // サイズが合わない等。次のdrawChartで回復
  }
}

/* ---------- CSVパース & 数値変換 ---------- */

function toNum(s) {
  if (s == null) return NaN;
  return Number(String(s).replace(/,/g, '').replace(/"/g, '').trim());
}

function parseCsvLine(line) {
  const out = [];
  let cur = "";
  let inQ = false;
  for (const ch of line) {
    if (ch === '"') { inQ = !inQ; continue; }
    if (ch === "," && !inQ) {
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out;
}

/* ---------- 指標計算 ---------- */

function calculateMA(data, period) {
  const result = new Array(data.length).fill(null);
  for (let i = period - 1; i < data.length; i++) {
    let sum = 0;
    for (let j = 0; j < period; j++) sum += data[i - j].close;
    result[i] = sum / period;
  }
  return result;
}

function calculateRSI(data, period) {
  const result = new Array(data.length).fill(null);
  if (data.length < period) return result;

  let gains = 0, losses = 0;
  for (let i = 1; i <= period; i++) {
    const diff = data[i].close - data[i-1].close;
    if (diff > 0) gains += diff; else losses -= diff;
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;

  if (avgLoss === 0) result[period] = 100;
  else result[period] = 100 - (100 / (1 + avgGain/avgLoss));

  for (let i = period + 1; i < data.length; i++) {
    const diff = data[i].close - data[i-1].close;
    const gain = diff > 0 ? diff : 0;
    const loss = diff < 0 ? -diff : 0;

    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;

    if (avgLoss === 0) result[i] = 100;
    else result[i] = 100 - (100 / (1 + avgGain/avgLoss));
  }
  return result;
}

function calculateMACD(data, shortP, longP, sigP) {
  const macdLine = new Array(data.length).fill(null);
  const signalLine = new Array(data.length).fill(null);
  const histogram = new Array(data.length).fill(null);

  let kS = 2 / (shortP + 1);
  let kL = 2 / (longP + 1);
  let emaS = data[0].close;
  let emaL = data[0].close;

  for (let i=0; i<data.length; i++) {
    const price = data[i].close;
    if (i===0) {
      emaS = price; emaL = price;
    } else {
      emaS = (price - emaS) * kS + emaS;
      emaL = (price - emaL) * kL + emaL;
    }

    if (i >= longP - 1) {
      macdLine[i] = emaS - emaL;
    }
  }

  let firstValid = longP - 1;
  if (firstValid < 0 || firstValid >= data.length) return { macd: macdLine, signal: signalLine, hist: histogram };

  let sigEma = macdLine[firstValid];
  let kSig = 2 / (sigP + 1);

  for (let i=firstValid; i<data.length; i++) {
    if (i === firstValid) {
      signalLine[i] = macdLine[i];
      sigEma = macdLine[i];
    } else {
      sigEma = (macdLine[i] - sigEma) * kSig + sigEma;
      signalLine[i] = sigEma;
    }
    histogram[i] = macdLine[i] - signalLine[i];
  }

  return { macd: macdLine, signal: signalLine, hist: histogram };
}

function calculateStochastic(data, kP, dP) {
  const kLine = new Array(data.length).fill(null);
  const dLine = new Array(data.length).fill(null);

  for (let i = kP - 1; i < data.length; i++) {
    let highest = -Infinity;
    let lowest = Infinity;
    for (let j = 0; j < kP; j++) {
      highest = Math.max(highest, data[i-j].high);
      lowest = Math.min(lowest, data[i-j].low);
    }

    const current = data[i].close;
    if (highest !== lowest) {
      kLine[i] = ((current - lowest) / (highest - lowest)) * 100;
    } else {
      kLine[i] = 50;
    }
  }

  for (let i = kP - 1 + dP - 1; i < data.length; i++) {
    let sum = 0;
    for (let j = 0; j < dP; j++) sum += kLine[i-j];
    dLine[i] = sum / dP;
  }

  return { k: kLine, d: dLine };
}

/* ---- 指標をまとめて再計算 ---- */
function recomputeIndicators() {
  if (candles.length === 0) {
    indicators.ma1 = []; indicators.ma2 = [];
    indicators.rsi = [];
    indicators.stoch = { k: [], d: [] };
    indicators.macd = { macd: [], signal: [], hist: [] };
    return;
  }
  indicators.ma1 = calculateMA(candles, params.ma1);
  indicators.ma2 = calculateMA(candles, params.ma2);
  indicators.rsi = calculateRSI(candles, params.rsi);
  indicators.stoch = calculateStochastic(candles, params.stochK, params.stochD);
  indicators.macd = calculateMACD(candles, params.macdShort, params.macdLong, params.macdSignal);
}

/* ---------- 初期化 ---------- */

function init() {
  mainCanvas = document.getElementById('mainChart');
  mainCtx = mainCanvas.getContext('2d');

  macdCanvas = document.getElementById('macdChart');
  macdCtx = macdCanvas.getContext('2d');

  stochCanvas = document.getElementById('stochChart');
  stochCtx = stochCanvas.getContext('2d');

  rsiCanvas = document.getElementById('rsiChart');
  rsiCtx = rsiCanvas.getContext('2d');

  tooltip = document.getElementById('tooltip');

  // 使い方モーダル
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('helpModal');
  const helpCloseBtn = document.getElementById('helpCloseBtn');

  const openHelp = () => {
    helpModal.style.display = 'flex';
    helpModal.setAttribute('aria-hidden', 'false');
  };
  const closeHelp = () => {
    helpModal.style.display = 'none';
    helpModal.setAttribute('aria-hidden', 'true');
  };

  helpBtn.addEventListener('click', openHelp);
  helpCloseBtn.addEventListener('click', closeHelp);
  helpModal.addEventListener('click', (e) => { if (e.target === helpModal) closeHelp(); });
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && helpModal.style.display === 'flex') closeHelp();
  });

  setupEventListeners();
  resizeCanvas();
}

/* ---------- リサイズ ---------- */

function resizeCanvas() {
  resetBackBuffers();
  const resize = (c) => {
    if(!c) return;
    const rect = c.getBoundingClientRect();
    c.width = rect.width;
    c.height = rect.height;
  };

  resize(mainCanvas);
  resize(macdCanvas);
  resize(stochCanvas);
  resize(rsiCanvas);

  drawChart();
}

/* ---------- CSV読み込み（旧版仕様で） ---------- */

function loadCsvData(csvText) {
  try {
    const lines = csvText.trim().split(/\r?\n/);
    if (lines.length < 2) throw new Error("データが空です");

    const header = parseCsvLine(lines[0]).map(s => s.replace(/\r/g,'').trim());

    const idxDate  = header.indexOf("日付");
    const idxOpen  = header.indexOf("始値");
    const idxHigh  = header.indexOf("高値");
    const idxLow   = header.indexOf("安値");
    const idxClose = header.indexOf("終値");

    if (idxDate < 0 || idxOpen < 0 || idxHigh < 0 || idxLow < 0 || idxClose < 0) {
      throw new Error("必須列(日付, 始値, 高値, 安値, 終値)が見つかりません");
    }

    const rows = lines.slice(1).map(parseCsvLine);

    candles = rows.map(r => ({
      date:  r[idxDate],
      open:  toNum(r[idxOpen]),
      high:  toNum(r[idxHigh]),
      low:   toNum(r[idxLow]),
      close: toNum(r[idxClose]),
    })).reverse();   // 最新を末尾に

    document.getElementById('status').textContent =
      `${candles.length}件のデータをロード (期間: ${candles[0].date} ~ ${candles[candles.length-1].date})`;

    displayCount = Math.min(100, candles.length);
    offsetX = 0;

    recomputeIndicators();
    updateGuiFromState();
    drawChart();

  } catch (e) {
    console.error(e);
    document.getElementById('status').textContent = "エラー: " + e.message;
  }
}

/* ---------- UI ---------- */

function updateGuiFromState() {
  const cSlider = document.getElementById('countSlider');
  const rSlider = document.getElementById('rangeSlider');
  const cLabel = document.getElementById('countLabel');
  const rLabel = document.getElementById('rangeLabel');

  if (candles.length === 0) return;

  cSlider.max = candles.length;
  cSlider.value = displayCount;
  cLabel.textContent = `${displayCount}本`;

  const maxOffset = Math.max(0, candles.length - displayCount);
  rSlider.max = maxOffset;
  rSlider.value = Math.floor(offsetX);

  const startIndex = Math.max(0, candles.length - displayCount - Math.floor(offsetX));
  const endIndex = Math.min(candles.length - 1, startIndex + displayCount - 1);

  if (candles[startIndex] && candles[endIndex]) {
    const fmt = d => d;
    rLabel.textContent = `${fmt(candles[startIndex].date)} ~ ${fmt(candles[endIndex].date)}`;
  }
}

function setupEventListeners() {
  document.getElementById('fileInput').addEventListener('change', e => {
    const f = e.target.files[0];
    if (f) {
      const r = new FileReader();
      r.onload = ev => loadCsvData(ev.target.result);
      r.readAsText(f);
    }
  });

  const inputs = document.querySelectorAll('.param-group input');
  inputs.forEach(inp => {
    inp.addEventListener('change', e => {
      const id = e.target.id;
      const val = parseInt(e.target.value, 10);
      if (val > 0) {
        if (id === 'ma1Period') params.ma1 = val;
        if (id === 'ma2Period') params.ma2 = val;
        if (id === 'rsiPeriod') params.rsi = val;
        if (id === 'stochK') params.stochK = val;
        if (id === 'stochD') params.stochD = val;
        if (id === 'macdShort') params.macdShort = val;
        if (id === 'macdLong') params.macdLong = val;
        if (id === 'macdSignal') params.macdSignal = val;

        recomputeIndicators();
        drawChart();
      }
    });
  });

  document.getElementById('countSlider').addEventListener('input', e => {
    displayCount = parseInt(e.target.value, 10);
    const maxOffset = Math.max(0, candles.length - displayCount);
    offsetX = Math.min(offsetX, maxOffset);
    updateGuiFromState();
    drawChart();
  });

  document.getElementById('rangeSlider').addEventListener('input', e => {
    offsetX = parseInt(e.target.value, 10);
    updateGuiFromState();
    drawChart();
  });

  const canvases = [mainCanvas, macdCanvas, stochCanvas, rsiCanvas];

  canvases.forEach(cvs => {
    if (!cvs) return;

    cvs.addEventListener('wheel', e => {
      e.preventDefault();
      if (candles.length === 0) return;

      const delta = e.deltaY > 0 ? 1 : -1;
      const step = Math.max(1, Math.floor(displayCount * 0.1));
      let newCount = displayCount + (delta * step);
      newCount = Math.max(10, Math.min(candles.length, newCount));

      if (newCount !== displayCount) {
        displayCount = newCount;
        const maxOffset = Math.max(0, candles.length - displayCount);
        offsetX = Math.min(offsetX, maxOffset);
        updateGuiFromState();
        drawChart();
      }
    }, { passive: false });

    cvs.addEventListener('mousedown', e => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartOffset = offsetX;
      document.body.style.cursor = 'grabbing';
    });

    cvs.addEventListener('mousemove', e => {
      if (isDragging) {
        const rect = cvs.getBoundingClientRect();   // ★ mainCanvas固定をやめる
        const w = rect.width - 100;
        const diffX = e.clientX - dragStartX;
        const ppc = w / displayCount;
        const candleMove = diffX / ppc;
        let newOffset = dragStartOffset + candleMove;
        const maxOffset = Math.max(0, candles.length - displayCount);
        newOffset = Math.max(0, Math.min(newOffset, maxOffset));
        offsetX = newOffset;
        updateGuiFromState();
        drawChart();
      } else {
        handleTooltip(e, cvs);
      }
    });

    cvs.addEventListener('mouseup', () => {
      isDragging = false;
      document.body.style.cursor = 'default';
    });

    cvs.addEventListener('mouseleave', () => {
      if(isDragging) {
        isDragging = false;
        document.body.style.cursor = 'default';
      }
      tooltip.style.display = 'none';
      drawCrosshair(-1);
    });
  });

  window.addEventListener('resize', resizeCanvas);
}

/* ---------- ツールチップ ---------- */

function handleTooltip(e, canvas) {
  if (!mainCanvas.candlePositions || candles.length === 0) return;

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;

  const closest = mainCanvas.candlePositions.find(p => 
    mouseX >= p.x - p.w/2 && mouseX <= p.x + p.w/2
  );

  if (closest) {
    const idx = closest.index;
    const c = candles[idx];

    const ma1 = indicators.ma1[idx];
    const ma2 = indicators.ma2[idx];
    const rsi = indicators.rsi[idx];
    const stochK = indicators.stoch.k[idx];
    const stochD = indicators.stoch.d[idx];
    const macd = indicators.macd.macd[idx];
    const sig  = indicators.macd.signal[idx];

    const fmt = n => (n!==null && n!==undefined && !Number.isNaN(n))
      ? n.toLocaleString(undefined, {maximumFractionDigits:2})
      : '-';

    let html = `<strong>${c.date}</strong><br>`;
    html += `始:${fmt(c.open)} 高:${fmt(c.high)}<br>`;
    html += `安:${fmt(c.low)} 終:${fmt(c.close)}<br>`;
    html += `<span style="color:#ff9800">MA${params.ma1}:${fmt(ma1)}</span> <span style="color:#2196f3">MA${params.ma2}:${fmt(ma2)}</span><br>`;
    html += `<span style="color:#9c27b0">RSI:${fmt(rsi)}</span><br>`;
    html += `<span style="color:#00bcd4">K:${fmt(stochK)}</span> <span style="color:#ff5722">D:${fmt(stochD)}</span><br>`;
    html += `MACD:${fmt(macd)} Sig:${fmt(sig)}`;

    tooltip.innerHTML = html;
    tooltip.style.display = 'block';

    let tx = e.clientX + 15;
    let ty = e.clientY + 15;
    if (tx + 150 > window.innerWidth) tx -= 160;

    tooltip.style.left = tx + 'px';
    tooltip.style.top = ty + 'px';

    drawCrosshair(closest.x);
  } else {
    tooltip.style.display = 'none';
    drawCrosshair(-1);
  }
}

/* ---------- 描画 ---------- */

function drawChart() {
  if (!mainCanvas) return;

  if (candles.length === 0) {
    resetBackBuffers();
    mainCtx.clearRect(0,0,mainCanvas.width, mainCanvas.height);
    mainCtx.fillStyle = '#666';
    mainCtx.textAlign = 'center';
    mainCtx.fillText("No Data", mainCanvas.width/2, mainCanvas.height/2);
    return;
  }

  let startIdx = Math.floor(candles.length - displayCount - offsetX);
  if (startIdx < 0) startIdx = 0;
  let endIdx = startIdx + displayCount;
  if (endIdx > candles.length) endIdx = candles.length;

  const visibleCandles = candles.slice(startIdx, endIdx);
  const visibleIndices = [];
  for(let i=startIdx; i<endIdx; i++) visibleIndices.push(i);

  if (visibleCandles.length === 0) return;

  drawMain(visibleCandles, visibleIndices);
  drawMacd(visibleIndices);
  drawStoch(visibleIndices);
  drawRsi(visibleIndices);

  saveBackBuffers();
}

function drawMain(visibleCandles, visibleIndices) {
  const ctx = mainCtx;
  const w = mainCanvas.width;
  const h = mainCanvas.height;
  const pad = { t: 20, b: 30, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;

  ctx.clearRect(0,0,w,h);

  let minP = Infinity, maxP = -Infinity;
  visibleCandles.forEach(c => {
    if (c.low < minP) minP = c.low;
    if (c.high > maxP) maxP = c.high;
  });

  const ma1 = indicators.ma1;
  const ma2 = indicators.ma2;

  visibleIndices.forEach(idx => {
    if (ma1[idx] != null) { minP = Math.min(minP, ma1[idx]); maxP = Math.max(maxP, ma1[idx]); }
    if (ma2[idx] != null) { minP = Math.min(minP, ma2[idx]); maxP = Math.max(maxP, ma2[idx]); }
  });

  const range = maxP - minP || 1;
  minP -= range * 0.05;
  maxP += range * 0.05;
  const scaleY = chartH / (maxP - minP);

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleCandles.length);
  const getY = (val) => pad.t + chartH - (val - minP) * scaleY;

  const barW = (chartW / visibleCandles.length) * 0.7;

  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  const gridSteps = 5;
  for(let i=0; i<=gridSteps; i++) {
    const y = pad.t + (chartH * i / gridSteps);
    const price = maxP - (maxP - minP) * (i/gridSteps);
    ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(w - pad.r, y); ctx.stroke();

    ctx.fillStyle = '#666';
    ctx.textAlign = 'left';
    ctx.fillText(price.toFixed(0), w - pad.r + 5, y + 4);
  }

  mainCanvas.candlePositions = visibleCandles.map((c, i) => ({
    x: getX(i),
    w: chartW / visibleCandles.length,
    index: visibleIndices[i],
    candle: c
  }));

  visibleCandles.forEach((c, i) => {
    const x = getX(i);
    const isUp = c.close >= c.open;
    ctx.fillStyle = isUp ? '#26a69a' : '#ef5350';
    ctx.strokeStyle = ctx.fillStyle;

    ctx.beginPath();
    ctx.moveTo(x, getY(c.high));
    ctx.lineTo(x, getY(c.low));
    ctx.stroke();

    const yOpen = getY(c.open);
    const yClose = getY(c.close);
    const hBody = Math.max(1, Math.abs(yOpen - yClose));
    ctx.fillRect(x - barW/2, Math.min(yOpen, yClose), barW, hBody);

    if (i % Math.ceil(visibleCandles.length/6) === 0) {
      ctx.fillStyle = '#999';
      ctx.textAlign = 'center';
      ctx.fillText(c.date, x, h - 5);
    }
  });

  const drawLine = (dataArr, color) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let moved = false;
    visibleIndices.forEach((idx, i) => {
      const val = dataArr[idx];
      if (val != null) {
        const x = getX(i);
        const y = getY(val);
        if (!moved) { ctx.moveTo(x, y); moved = true; }
        else ctx.lineTo(x, y);
      }
    });
    ctx.stroke();
  };

  drawLine(ma1, '#ff9800');
  drawLine(ma2, '#2196f3');
}

function drawMacd(visibleIndices) {
  if (collapsed.macd) return;

  const ctx = macdCtx;
  const w = macdCanvas.width;
  const h = macdCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;

  ctx.clearRect(0,0,w,h);

  const data = indicators.macd;

  let minV = Infinity, maxV = -Infinity;
  visibleIndices.forEach(idx => {
    const m = data.macd[idx];
    const s = data.signal[idx];
    const hi = data.hist[idx];
    if (m!=null) { minV = Math.min(minV, m); maxV = Math.max(maxV, m); }
    if (s!=null) { minV = Math.min(minV, s); maxV = Math.max(maxV, s); }
    if (hi!=null){ minV = Math.min(minV, hi); maxV = Math.max(maxV, hi); }
  });

  if (minV === Infinity) { minV = -1; maxV = 1; }
  const range = Math.max(0.0001, maxV - minV);
  const scaleY = chartH / range;

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v - minV) * scaleY;

  const y0 = getY(0);
  ctx.strokeStyle = '#ccc'; ctx.beginPath(); ctx.moveTo(pad.l, y0); ctx.lineTo(w-pad.r, y0); ctx.stroke();

  const barW = (chartW / visibleIndices.length) * 0.7;
  visibleIndices.forEach((idx, i) => {
    const v = data.hist[idx];
    if (v != null) {
      const x = getX(i);
      const y = getY(v);
      ctx.fillStyle = v >= 0 ? '#26a69a' : '#ef5350';
      ctx.fillRect(x - barW/2, Math.min(y, y0), barW, Math.abs(y - y0));
    }
  });

  const drawLine = (arr, color) => {
    ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath();
    let moved = false;
    visibleIndices.forEach((idx, i) => {
      const v = arr[idx];
      if (v != null) {
        if(!moved) { ctx.moveTo(getX(i), getY(v)); moved = true; }
        else ctx.lineTo(getX(i), getY(v));
      }
    });
    ctx.stroke();
  };

  drawLine(data.macd, '#2196f3');
  drawLine(data.signal, '#ff9800');

  ctx.fillStyle = '#666'; ctx.textAlign='left';
  ctx.fillText(`MACD(${params.macdShort},${params.macdLong},${params.macdSignal})`, 5, 10);
  ctx.fillText(maxV.toFixed(2), w-pad.r+5, pad.t+10);
  ctx.fillText(minV.toFixed(2), w-pad.r+5, h-pad.b);
}

function drawStoch(visibleIndices) {
  if (collapsed.stoch) return;

  const ctx = stochCtx;
  const w = stochCanvas.width;
  const h = stochCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;

  ctx.clearRect(0,0,w,h);

  const data = indicators.stoch;
  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v / 100) * chartH;

  ctx.strokeStyle = '#eee'; ctx.setLineDash([4,4]);
  [20, 80].forEach(level => {
    const y = getY(level);
    ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(w-pad.r, y); ctx.stroke();
  });
  ctx.setLineDash([]);

  const drawLine = (arr, color) => {
    ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath();
    let moved = false;
    visibleIndices.forEach((idx, i) => {
      const v = arr[idx];
      if (v != null) {
        if(!moved) { ctx.moveTo(getX(i), getY(v)); moved = true; }
        else ctx.lineTo(getX(i), getY(v));
      }
    });
    ctx.stroke();
  };

  drawLine(data.k, '#00bcd4');
  drawLine(data.d, '#ff5722');

  ctx.fillStyle = '#666'; ctx.textAlign='left';
  ctx.fillText(`Stoch(${params.stochK},${params.stochD})`, 5, 10);
}

function drawRsi(visibleIndices) {
  if (collapsed.rsi) return;

  const ctx = rsiCtx;
  const w = rsiCanvas.width;
  const h = rsiCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;

  ctx.clearRect(0,0,w,h);

  const data = indicators.rsi;
  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v / 100) * chartH;

  ctx.fillStyle = 'rgba(156, 39, 176, 0.05)';
  const y70 = getY(70);
  const y30 = getY(30);
  ctx.fillRect(pad.l, y70, chartW, y30 - y70);

  ctx.strokeStyle = '#ccc'; ctx.setLineDash([4,4]);
  [30, 70].forEach(level => {
    const y = getY(level);
    ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(w-pad.r, y); ctx.stroke();
  });
  ctx.setLineDash([]);

  ctx.strokeStyle = '#9c27b0'; ctx.lineWidth = 1.5; ctx.beginPath();
  let moved = false;
  visibleIndices.forEach((idx, i) => {
    const v = data[idx];
    if (v != null) {
      if(!moved) { ctx.moveTo(getX(i), getY(v)); moved = true; }
      else ctx.lineTo(getX(i), getY(v));
    }
  });
  ctx.stroke();

  ctx.fillStyle = '#666'; ctx.textAlign='left';
  ctx.fillText(`RSI(${params.rsi})`, 5, 10);
}

/* ---------- クロスヘア（再描画しない） ---------- */

function drawCrosshair(x) {
  restoreBackBuffers();
  if (x < 0) return;

  const draw = (ctx, h) => {
    if(!ctx) return;
    ctx.save();
    ctx.strokeStyle = '#999';
    ctx.setLineDash([3,3]);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, h);
    ctx.stroke();
    ctx.restore();
  };

  draw(mainCtx, mainCanvas.height);
  if (!collapsed.macd) draw(macdCtx, macdCanvas.height);
  if (!collapsed.stoch) draw(stochCtx, stochCanvas.height);
  if (!collapsed.rsi) draw(rsiCtx, rsiCanvas.height);
}

/* ---------- インジケータ位置/折りたたみ ---------- */

function toggleIndicator(key) {
  collapsed[key] = !collapsed[key];
  const wrapper = document.getElementById(key + 'Wrapper');
  if (collapsed[key]) wrapper.classList.add('collapsed');
  else wrapper.classList.remove('collapsed');
  setTimeout(resizeCanvas, 210);
}

function moveIndicator(key, dir) {
  const container = document.getElementById(key + 'Container');
  const parent = document.getElementById('indicatorsList');
  if (dir === 'up') {
    const prev = container.previousElementSibling;
    if (prev) parent.insertBefore(container, prev);
  } else {
    const next = container.nextElementSibling;
    if (next) parent.insertBefore(next, container);
  }
  setTimeout(resizeCanvas, 0);
}

window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
